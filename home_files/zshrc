bindkey -e
bindkey "^[[3~" delete-char # fix the delete key?

set -k # treat comments in interactive shells as... comments

setopt complete_aliases

HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt appendhistory

# treat different path segments as different words, kinda like bash
export WORDCHARS=${WORDCHARS//\//}

maybe.() { [ -e "$1" ] && . $1 }

# git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions
maybe. ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh

# git clone https://github.com/zdharma/fast-syntax-highlighting ~/.zsh/fast-syntax-highlighting
if [ -e ~/.zsh/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh ]; then
  . ~/.zsh/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh
  fast-theme -q clean
fi

maybe. ~/code/google-scripts/etc/zshenv

export PAGER="/bin/sh -c \"unset MANPAGER;col -b -x | view --cmd 'let g:no_session_dot_vim=1' -c 'set ft=man nomod nolist nowrap' -c 'map q :q<CR>' -c 'map <SPACE> <C-D>' -c 'nmap K :Man <C-R>=expand(\\\"<cword>\\\")<CR><CR>' -\""
export MANPAGER="$PAGER"

export EDITOR=vim
if which mvim &>/dev/null; then
  export VISUAL="mvim -f"
fi

[ -e ~/.pythonrc ] && export PYTHONSTARTUP="$HOME/.pythonrc"

# for nice git diffs:
# git clone https://github.com/so-fancy/diff-so-fancy.git ~/code/diff-so-fancy
[ -e ~/code/diff-so-fancy ] && export PATH="$PATH:$HOME/code/diff-so-fancy"

if which lsd >/dev/null; then
  alias ls="lsd --date relative -tr"

  # if a machine has icon fonts installed and you want lsd to use them, run:
  # echo 'export LC_HAS_ICON_FONT=yes' >> ~/.zshenv
  if [ -z "$LC_HAS_ICON_FONT" ]; then
    alias ls="${aliases[ls]} --icon never"
  fi
else
  alias ls="ls --color=auto -tr"
fi
alias ll="ls -l"

zstyle ':completion:*' completer _complete _list _oldlist _expand _ignored _correct _approximate
zstyle ':completion:*' completions 1
zstyle ':completion:*' glob 1
zstyle ':completion:*' insert-unambiguous true
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' matcher-list 'm:{[:lower:]}={[:upper:]}' 'r:|[._-/]=* r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' max-errors 1
zstyle ':completion:*' menu select=1
zstyle ':completion:*' original true
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' substitute 1
zstyle ':completion:*' verbose true
zstyle :compinstall filename '/Users/aaronstacy/.zshrc'

autoload -Uz compinit
compinit

autoload -Uz add-zsh-hook

_format_runtime_ms() {
    local t="$1."
    local d=$((t/1000/60/60/24))
    local h=$((t/1000/60/60%24))
    local m=$((t/1000/60%60))
    local M=$((t%1000))

    if [[ $t -lt 1000 ]]; then
      printf "%.0fms" $M
    elif [[ $t -lt $((60 * 1000)) ]]; then
      printf "%.3fs" $((t/1000.))
    elif [[ $t -lt $((60 * 60 * 1000)) ]]; then
      printf "%.0fm %.3fs" $m $((t/1000. % 60))
    elif [[ $t -lt $((24 * 60 * 60 * 1000)) ]]; then
      printf "%.0fh %.0fm %.3fs" $h $m $((t/1000. % 60))
    else
      printf "%.0fd %.0fh %.0fm %.3fs" $d $h $m $((t/1000. % 60))
    fi
}

_get_git_dir() {
  local indicator="üÖñ "
  if ! git diff --exit-code --name-only --quiet; then
    indicator="%%F{1}$indicator%%f"
  elif git status -sb | grep ahead 2>&1 >/dev/null; then
    indicator="%%F{3}$indicator%%f"
  fi

  if [[ -d .git ]]; then
    printf "${indicator}`basename $PWD`"
  else
    local gitdir="$(dirname $(git rev-parse --git-dir))"
    local gitbasedir="$(basename $gitdir)"
    printf "${indicator}$(echo $PWD | sed -e "s|^$gitdir|$gitbasedir|")"
  fi
}

_get_g4_dir() {
  local indicator="üÖí "
  if g4 p | grep -e '[^[:space:]]' 2>&1 >/dev/null; then
    indicator="%%F{1}$indicator%%f"
  fi

  if pwd | grep /google/src/cloud/$USER 2>&1 >/dev/null; then
    local g4g4d="`g4 g4d`"
    local client="$(basename $(dirname $g4g4d))"
    printf "${indicator}$(echo $PWD | sed -e "s|^$g4g4d|$client|")"
  fi
}

add-zsh-hook preexec() {
  _zsh_command_timer=$(($(print -P %D{%s%6.})/1000))
}

add-zsh-hook precmd() {
  if [[ -d .git ]] || git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    psvar[2]="`_get_git_dir`"
  elif echo $PWD | grep -e "^/google/src/cloud/$USER" 2>&1 >/dev/null; then
    psvar[2]="`_get_g4_dir`"
  else
    psvar[2]="%~"
  fi

  # Something like this in the crontab should keep this up to date:
  # * * * * * if /usr/local/bin/gcertstatus -nocheck_ssh -quiet; then rm -f ~/.gcertstatus_expired; touch ~/.gcertstatus_valid; else rm -f ~/.gcertstatus_valid; touch ~/.gcertstatus_expired; fi
  if [ -e ~/.gcertstatus_expired ]; then
    psvar[3]="%F{1}‚É†%f"
  else
    psvar[3]=""
  fi

  if [ $_zsh_command_timer ]; then
    local now=$(($(print -P %D{%s%6.})/1000))
    psvar[5]="$(_format_runtime_ms $(($now-$_zsh_command_timer)))"
    unset _zsh_command_timer
  else
    psvar[5]=""
  fi

  psvar[6]="$(date '+%H:%M %b%d')"

  local zero='%([BSUbfksu]|([FK]|){*})'
  local leftside="%F{87}%b‚àÇ%b%f%1v ${psvar[2]} ${psvar[3]} "
  local leftsidelen=${#${(S%%)leftside//$~zero/}}
  local rightside='%F{238}%5v %6v%f'
  local rightsidelen=${#${(S%%)rightside//$~zero/}}
  local spacecount=$(($COLUMNS - $leftsidelen - $rightsidelen))
  [[ "${psvar[1]}" = wÃºoÕãr·∑åk·∑ø ]] && spacecount=$(($spacecount + 4)) # account for diacritics
  psvar[4]="${(l:${spacecount}:: :)}"

}

# psvar[1] -- host name
# psvar[2] -- directory (or source control info)
# psvar[3] -- auth state
# psvar[4] -- spaces between left and right side
# psvar[5] -- duration of last command
# psvar[6] -- current date
_set_ps1() {
  if which scutil >/dev/null; then
    psvar[1]=`scutil --get ComputerName`
    [[ $psvar[1] = aaronstacy-macbookpro2 ]] && psvar[1]=«ù…Øo…•
  else
    psvar[1]=`hostname`
    [[ $psvar[1] = aaronstacy-goobuntu.aus.corp.google.com ]] && psvar[1]=wÃºoÕãr·∑åk·∑ø
  fi

  setopt prompt_subst # expand variables

  PROMPT='
%F{87}%B‚àÇ%b%f%1v $psvar[2] $psvar[3] %4v%F{238}%5v %6v%f
%(?.%F{87}.%F{160})¬ß%f '
}
_set_ps1
unset _format_runtime_ms _get_git_dir _get_g4_dir _set_ps1

