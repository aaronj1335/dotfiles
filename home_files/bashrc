# the alleged .bashrc file of one aaron r. stacy



# first of all...
alias yo="echo 'screw you i am not a morning person'"



### wranging the path into submission ###
[ -d $HOME/downfrom-jmake/bin ] && \
	export PATH="${PATH}:$HOME/downfrom-jmake/bin"

[ -d /usr/local/mysql/bin ] && export PATH="$PATH:/usr/local/mysql/bin"

[ -d /usr/local/sbin ] && export PATH="$PATH:/usr/local/sbin"

[ -d /usr/local/cuda/bin ] && export PATH="$PATH:/usr/local/cuda/bin"

[ -d /Library/PostgreSQL/8.3/bin/ ] && \
	export PATH="$PATH:/Library/PostgreSQL/8.3/bin"

[ -d $HOME/repositories/siq/bin ] && \
	export PATH="$PATH:$HOME/repositories/siq/bin"

[ -d $HOME/repositories/pdub ] && export PATH="$PATH:$HOME/repositories/pdub"

[ -d "$HOME/bin" ] && export PATH="$PATH:$HOME/bin"



### the arbitrary and entirely personal aliases ###
alias l='ls '
alias ll='ls -l'
alias grep="grep --color"

# one vim to find them, one vim to rule them all...
[ -f '/Applications/MacVim.app/Contents/MacOS/Vim' ] && 
	alias vim='/Applications/MacVim.app/Contents/MacOS/Vim'



### other various exports ###
export EDITOR=vim # this is most important...
if [ "$TERM" = "xterm-256color" ]; then
	export PS1="
\[\e[38;5;247m\]\u\[\e[38;5;87m\]@\[\e[38;5;247m\]\h\[\e[38;5;87m\]:\[\e[38;5;255m\]\w  \[\e[38;5;30m\]\T \[\e[38;5;30m\]\D{%d-%b}\[\e[0;1m\] 
\[\e[38;5;87m\]$\[\e[0m\] "
else
	export PS1="\[\033[0m\][\[\033[36m\]\u@\h\[\033[32m\]\w\[\033[0m\]]\n\[\033[31m\]\$ \[\033[0m\]"
fi

export PAGER="/bin/sh -c \"unset PAGER;col -b -x | view -c 'set ft=man nomod nolist nowrap' -c 'map q :q<CR>' -c 'map <SPACE> <C-D>' -c 'nmap K :Man <C-R>=expand(\\\"<cword>\\\")<CR><CR>' -\""

export LSCOLORS=dxfxcxdxbxegedabagacad
if [ `uname` = "Linux" ]; then
	alias ll='ls -l --color=auto'
	eval "$(dircolors -b ~/.dir_colors)"
fi
export CLICOLOR="true"

set -o emacs



### tab completion is empirically the best part of unix ###
# check for bash completion on mac os x
[ -f /opt/local/etc/bash_completion ] && source /opt/local/etc/bash_completion

# and my own copy of git bash completion (in order of precedence)
potention_locations="
/opt/local/share/doc/git-core/contrib/completion/git-completion.bash
$HOME/bin/home_files/git-completion.bash"
if which git &>/dev/null; then
	for f in $potention_locations; do
		if [ -f "$f" ]; then
			source "$f"
			break
		fi
	done
fi

# and the npm completion
[ -f "$HOME/bin/home/files/npm-completion.bash" ] && which npm &>/dev/null && \
	source "$HOME/bin/home_files/npm-completion.bash"

# and this is where i set up tab completion for python
[ -f ~/.pythonrc ] && export PYTHONSTARTUP="$HOME/.pythonrc"

# finally tell bash not to include CVS in the possible completions (b/c it sux)
export FIGNORE="$FIGNORE:CVS"



### the ever-loathsome CVS, and a spot of miscellany ###
export CVSROOT=":ext:astacy@cvs.storediq.com:/home/cvsroot.2"

# set tab width to 4 (useful when you're running "cat" on a file), but it makes
# things all screwy when you ssh somewhere
#if which tabs &>/dev/null; then
#    tabs -4
#fi



### and the ever stalwart ssh-agent ###
[ -f "$HOME/.ssh-agent" ] && . $HOME/.ssh-agent

########################################################################
############       At-Work ssh-agent setup               ###############
########################################################################

# this is for when you're working on many different computers that all
# nfs-mount your home dir

# this shouldn't run if i'm just running a remote command via ssh

#if [ "`tty`" != "not a tty" ]; then
#  ssh_agent_pids="`ps -wef | grep $USER.*ssh-agent | egrep -v grep\|defunct | awk '{print $2}'`"
##echo "\$ssh_agent_pids \"$ssh_agent_pids\""
#  num_ssh_agent_pids=`echo "$ssh_agent_pids" | wc -w`

#  # kill off all ssh-agents that don't correspond to the .ssh-agent-* file
#  if [ -f "$HOME/.ssh-agent-`uname -n`" ]; then
##echo "'.ssh-agent-`uname -n`' is a file"
#    current_ssh_agent_pid_from_file="`grep SSH_AGENT_PID= $HOME/.ssh-agent-$(uname -n)| cut -d';' -f1| cud -d'=' -f2`"
#  else
##echo "'.ssh-agent-`uname -n`' is not a file"
#    current_ssh_agent_pid_from_file=""
#  fi
##echo "\$current_ssh_agent_pid_from_file \"$current_ssh_agent_pid_from_file\""

#  if [ -n "$current_ssh_agent_pid_from_file" ]; then
#    ssh_agent_pids_to_kill="`echo "$ssh_agent_pids"| grep -v $current_ssh_agent_pid_from_file`"
#  else
#    ssh_agent_pids_to_kill="$ssh_agent_pids"
#  fi
##echo "\$ssh_agent_pids_to_kill \"$ssh_agent_pids_to_kill\""
#  [ -n "$ssh_agent_pids_to_kill" ] && kill $ssh_agent_pids_to_kill

#  # now that the extraneous ssh-agent's are dead, get the remaining ssh-agent
#  # pid (if it exists)
#  running_ssh_agent_pid="`ps -wef| grep $USER.*ssh-agent| egrep -v grep\|defunct | awk '{print $2}'`"
##echo "\$running_ssh_agent_pid \"$running_ssh_agent_pid\""

#  if [ "$current_ssh_agent_pid_from_file" != "$running_ssh_agent_pid" ]\
#    || [ -z "$running_ssh_agent_pid" ]; then
#    # if there's a ~/.ssh-agent-<hostname> file, it's invalid since there
#    # aren't any ssh-agent's running, so delete it
#    [ -f $HOME/.ssh-agent-`uname -n` ] && rm $HOME/.ssh-agent-`uname -n`

#    # now start up an ssh-agent and source the env vars
##echo "restarting ssh-agent process"
#    nohup ssh-agent -s | grep -v echo > $HOME/.ssh-agent-`uname -n`
#    source $HOME/.ssh-agent-`uname -n`
#    ssh-add
#  else
##echo "using current ssh-agent process"
#    source $HOME/.ssh-agent-`uname -n`
#  fi
#fi
